
# 1. Скопируйте код выше и создайте объект motifs2
motifs2 <- matrix(c(
  "a", "C", "g", "G", "T", "A", "A", "t", "t", "C", "a", "G",
  "t", "G", "G", "G", "C", "A", "A", "T", "t", "C", "C", "a",
  "A", "C", "G", "t", "t", "A", "A", "t", "t", "C", "G", "G",
  "T", "G", "C", "G", "G", "G", "A", "t", "t", "C", "C", "C",
  "t", "C", "G", "a", "A", "A", "A", "t", "t", "C", "a", "G",
  "A", "C", "G", "G", "C", "G", "A", "a", "t", "T", "C", "C",
  "T", "C", "G", "t", "G", "A", "A", "t", "t", "a", "C", "G",
  "t", "C", "G", "G", "G", "A", "A", "t", "t", "C", "a", "C",
  "A", "G", "G", "G", "T", "A", "A", "t", "t", "C", "C", "G",
  "t", "C", "G", "G", "A", "A", "A", "a", "t", "C", "a", "C"
), nrow = 10, byrow = TRUE)

# 2. Преобразуйте матрицу в верхний регистр (toupper())
motifs2_1 <- toupper(motifs2)

# 3. Постройте COUNT-матрицу и PROFILE-матрицу (через apply() и factor())
#COUNT матрица — это таблица, которая показывает, сколько раз каждый нуклеотид встречается в каждой позиции выровненного мотива
count_matrix <- apply(motifs2_1, 2, function(col) table(factor(col, levels = c("A", "C", "G", "T"))))
#apply() применяет функцию к матрице
# 2 означает: применяем функцию к столбцам
# apply() для каждого столбца она вызывает функцию function(col) col содержит все элементы текущего столбца
# тело функции table(factor(col, levels = c("A", "C", "G", "T")
#col - получает столбец данных
# factor(col, levels = c("A", "C", "G", "T")) - преобразует в фактор с фиксированными уровнями
#table(...) - подсчитывает частоты каждого уровня
# Эквивалентная именная функция count <-function(col) { result <- table(factor(col, levels = c("A", "C", "G", "T")))
    #return(result)
#}

#Profile-матрица мотивов - это таблица вероятностей, которая показывает:
#Строки: 4 нуклеотида (A, C, G, T)
#Столбцы: позиции в мотиве
#Значения: вероятность встретить каждый нуклеотид в каждой позиции
profile <- apply(motifs2_1, 2, function(x) {
  counts <- table(factor(x, levels = c("A", "C", "G", "T")))
  counts / sum(counts)
})

# 4. Используя свою функцию scoreMotifs(), вычислите score для motifs2
scoreMotifs <- function(motifs) {
  score <- 0#Инициализация переменной score - начинаем с нуля, будем накапливать результат
  for (col in 1:ncol(motifs)) {
    column <- motifs[, col]
    # Находим наиболее частый символ в столбце
    freq <- table(column)
    max_freq <- max(freq)
    # Добавляем cost для этого столбца
    score <- score + (length(column) - max_freq)
  }
  return(score)
}
#ncol(motifs) - количество столбцов в матрице
#1:ncol(motifs) создает последовательность чисел от 1 до числа столбцов
#col - переменная, которая поочередно принимает значения 1, 2, 3, ... до последнего столбца
#motifs[, col] - получаем все элементы столбца col
#able(column) подсчитывает, сколько раз каждый символ встречается в столбце
#max(freq) находит наибольшее значение в таблице частот
#length(column) - общее количество символов в столбце (число строк)
#(length(column) - max_freq) - количество "несогласованных" символов в столбце
all_score <- scoreMotifs(motifs2_1)

# 5. Реализуйте и протестируйте функцию getConsensus() на этой матрице для получения консенсусной последовательности
#Консенсусная последовательность - это строка наиболее частых нуклеотидов в каждой позиции мотива, 
#полученная из profile-матрицы выбором максимумов по столбцам.
consensus <- apply(profile, 2, function(col) {
  nucleotides <- c("A", "C", "G", "T")
  nucleotides[which.max(col)]
})
consensus_string <- paste(consensus, collapse = "")# объединяет все символы в одну строку
#which.max(col) - находит индекс максимального значения в столбце
#nucleotides[which.max(col)] - берет нуклеотид по этому индексу

# 6. Постройте barplot частот нуклеотидов для любого выбранного столбца
#цвет столбцов(col): “skyblue”
#заголовок(main): "Частоты нуклеотидов в 1-м столбце"
freq <- table(motifs2_1[, 1])# Выбираем первый столбец
barplot(freq, 
        col = "skyblue",
        main = "Частоты нуклеотидов в 1-м столбце")
